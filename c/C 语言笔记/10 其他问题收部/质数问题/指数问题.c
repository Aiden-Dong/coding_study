// 这个求质数的方法主要分为一下几部分 :

#include<stdio.h>
#include<math.h>
#define N 100
int main()
{
	int i , j , n , m ;
	int a[N];

	a[1]=2;
// ================== 第一部分====================================
	/*
		这部分的内容是先列出 1-100  的可能质数集合  即奇数部分 也就是
		因为除了 2 其他数不可能为 质数 !!!!
	*/
	for(i=3 , j=2 ; i < N ; i+=2 , j++)
		a[j]=i;				// 2 3 5 7 9 11 .................

	// 结果是将a[1]~a[50] 存储为 : 2 3 5 7 9 11 13 15 17 19 21 23 25 ............99 



// ==================第二部分=========================================
	/*
		第二部分为关键部分 ; 首先是将集合内部的合数都变为 0 ; 
		在接下来的运算中 ， 如果用作检测的参数为 合数 a[j] 将被跳过 即只是用质数来检测 ;
		（我也是刚从网上查的 ， 任何一个合数都可以分解为两个质数相乘 ， 这就是: 哥德巴赫猜想 ）
	*/

	for( i = 1 ; i < N/2+1 ; i++)					// i 从以到 50 
		for(j=1 ; a[j] < sqrt(a[i])+1 ; j++)	// 从 2 到 sqrt (a[i]) 之前 
		{
			if( a[j]==0 )
			{
				printf ("j = %d\n" , j);
				continue;
			}
			if(a[i]%a[j]==0)
			{
				a[i] = 0 ;	// 如果a[i] 为合数 a[i] = 0 ;
				break;
			}
		}
	// 出来的结果是 在集合内部 除了质数 ， 合数变为 0 ;



// ==================第三部分==========================================
		/*
			将质数凑在一起  简单来看 就是将类似 1 0 1 0 1 0 1 0 1 0 0 0 1 0 1 1 1 0 0 1 1 0 0 0 的数字转换为1 1 1 1 1 1 1 1 1 1 1
			用 n 记录 长度 // 并且 n 是用来交换数字使用 （实现依据 : n 一定 小于等于 i 这样使得数据不被破坏）
		*/
	for(i=1,n=0 ; i<N/2+1 ; i++)
		if(a[i])	// 如果 a[i] 为质数 
			a[++n]=a[i];
	// 结果是 : 所有的质数被筛选出来 长度为 n ;

// =================第四部分==========================================
		/*
			打印出结果
		*/
	for(i=1,m=0;i<n+1;i++)
	{
		printf("%5d",a[i]);
		m++;
		if(m==0)
		{
			printf("\n");
			m=0;
		}
	}
	// 这里唯一不解的就是 m 有什么作用 m++ 后m 不可能为0 ； 那么 if 又有什么作用？？？

		return 0;
}
