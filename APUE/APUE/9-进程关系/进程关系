终端登陆：

     当用户正确登陆， longin 就完成下列动作：
     1）将当前工作目录更改为用户起始目录
     2）调用chown更改该终端的所有权， 使登陆用户成为它的所有者，
     3）将对该终端设备的访问权限变成“用户读和写”
     4）调用setgid 及 initgroup设置环境的组 ID
     5）用 login 得到的所有信息初始化环境： 起始目录， shell, 用户名以及系统默认路径
     6）longin 进程更改为登陆用户的用户ID，并调用该用户的登陆shell；

进程组：

	  #include <unistd.h>
	  pid_t getpgrp(void);						// 获取进程组
	  int setpgrp(pid_t pid, pid_t pgid);				// 加入一个新的进程组或创建一个进程组
	  
	 说明：
	 1） 每一个进程都有一个组长进程, 组长进程的组ID 等于其进程的ID
	 2） 进程组组长可以创建进程组，创建改组中的进程， 然后终止，只要在某时刻进程组中有成员存在， 则进程组就存在，
	 3）一个进程只能为他自己或他的子进程设置进程组，在子进程调用exec 之后， 他就不再更改其子进程的ID
	 4）如果 pid == pgid ， 则由 pid 指定的进程将变成进程组的组长， 如果 pid == 0 则使用调用者的进程 ID ， 
	      如果 pgid == 0 则由pid 指定的进程 ID 用作进程组 ID

会话：
	 
	 #include <unistd.h>
	 pid_t setsid(void);		// 创建一个新的会话
	 
	 说明：
	       1） 如果该调用进程已经是一个新进程组的组长， 则返回出错
	       2） 该进程变成新会话的 会话首进程 ， 此时， 该进程是新会话中的唯一进程。
	       3） 该进程成为一个新进程组的组长进程。新进程组ID 是该调用进程的进程ID
	       4） 该进程没有控制终端，如果在调用 setsid 之前有一个控制终端， 则联系被切断
	       
终端控制:

	  说明：
		    1）一个会话可以有一个控制终端， 者通常是终端设备或伪终端设备
		    2）建立与控制 终端连接 的 会话首进程 被称为控制进程
		    3） 一个会话中的几个进程组可被分成一个前台进程组以及多个后台进程组
		    4）无论何时键入中断键， 都会将中断信号发送至前台进程组的所有进程
		    5）无论何时键入退出键， 都会将退出信号发送至前台进程组的所有进程
		    6）如果终端接口监测到断开链接， 则将挂断信号发送至控制进程
		    
前台进程组：

		    #include <unistd.h>
		    pid_t tcgetpgrp(int fd);				// 获取前台进程组
		    int tcsetpgrp(int fd, pid_t pgrpid);		// 指定前台进程组
		    
		    说明：
			  1) 如果进程有一个控制终端， 则该进程可以调用 tcsetpgrp 将前台进程组 ID 设置为 pgrpid. 
			      pgrpid 值应当为同一会话中的一个进程组ID
			  2) 如果在一个会话中的后台进程想要与控制终端进行通话， 则通话被忽略
			  3) 当后台停止的进程重新接受到 SIGCONT 信号转到运行状态时， 不会立即设置其进程组为前台进程组
			      可以调用 fg(1) 命令手动设置其前台进程组 
		#include <termios.h>
		pid_t tcgetsid(int fd);		// 获得会话首进程的进程组 ID
		
		 说明：
		    1） 当存在后台进程试图读一个终端数据时, 终端设备驱动程序将检测到这种情况， 并且向后台作业发送一个特定的信号 ： SIGTTIN 
			  该信号通常会停止此后台作业；
		    2)   在用户禁止后台作业向控制终端写时， 该作业的cat 命令试图写其标准输出， 此时控制终端程序识别出该写操作来自后台进程， 
		    于是向该作业 发送SIGTTOU 信号；
		    
		
孤儿进程：

	  条件:
		    1)  该组中的成员的父进程要么是该组中的成员， 要么不属于该会话的成员
		    2） 非孤儿进程： 存在一个进程， 其父进程属于该会话中的其他进程组
		    
		    在父进程终止后， 进程组包含一个停止进程， 进程组成为孤儿进程组， POSIX.1 要求想起新孤儿进程组中处于停止状态的每一个进程发送一个
		    挂断信号而后发送一个继续信号
		  
