#include <stdio.h>
#include "mgraph.h"

/* ******************************************************************************************************************************
 * 普利姆算法 ：
 *            核心思想 ： 从零入正 将所有的顶点看成未联通跟以联通两个整体 ；
 *
 *                        声明一个 adjvex 数组用于保存相关顶点下标 ：数组下标代表这对应下标的顶点 adjvex 如果存在 adjvex[a] = b 说明b
 *						  与 a 相链接 并且权值是 lowcost;
 *						  
 *						  lowcast 用于保存联通的树（整体型） 到未联通的顶点 的最小权值
 *
 *						  每次从 lowcost 所保存的最小权值里找到值最小并且不为0（将已经联通的顶点对应的权值置为 0）的加入到已联通的行列
 *						  并且每次都新加入的顶点中查找与未联通的顶点的权值 与 lowcast 的对应权值进行比较 保留小的
 * ******************************************************************************************************************************
*/
void MinispanTree_prim (pMGraph G)
{
	int min , i , j , k ,a;
	int adjvex[MAX_SIZE];   // 保存相关顶点下标
	int lowcost[MAX_SIZE];  // 保存相关顶点的权值

	lowcost[0] = 0 ;  // v0 作为最小生成树的根开始遍历，权值为 0
	adjvex[0] = 0;    // v0 第一个加入
	
	// 初始化操作
	for (i = 1 ; i < G->Vexnum ; i++)
	{
		lowcost[i] = G->arcs[0][i];   // 邻接矩阵第0行所有权值先加入数组
		adjvex[i] = 0;              // 初始化所有先为v0 的下标
	}

	// 真正构造最小生成树的过程
	for (a = 1 ; a < G->Vexnum ; a++)
	{
		
		min = 0x7fffffff ;  // 初始化最小权值为65535等不可能数值
		j = 1 ; 
		k = 0 ;

		while (j < G->Vexnum)
		{
			// 找出Lowcost数组已存储的最小权值
			if (lowcost[j] != 0 && lowcost[j] < min)
			{
				min = lowcost[j];
				k = j;    // 将发现的最小权值的下标存入k ，以待使用
			}
			j++;
		}

		// k 是未联通的顶点
		// adjvex[k] 是对应的以联通树中到达 顶点 k 的最小权值的对应顶点
		
		// 打印当前顶点最小的边
		printf (" (%d %d) " , adjvex[k] , k); 
		lowcost[k] = 0;  // 将当前顶点的权值设为0 表示此顶点已经完成任务

		// 邻接矩阵k 行逐个遍历全部顶点
		for ( j = 1 ; j < G->Vexnum ; j++)
		{
			if (lowcost[j] != 0 && G->arcs[k][j] < lowcost[j])
			{
				lowcost[j] = G->arcs[k][j];
				adjvex[j] = k;
			}
		}
	
	}
}