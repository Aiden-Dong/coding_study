#include "mgraph.h"
#include <stdio.h>

/*
** ******************************************************************************************************************
 * 迪杰斯特拉算法 :  求解此顶点到其他每一个顶点的最短路径
 *			方法 ：
 *					 声明一个存放此顶点到其他顶点的数组 ， 声明一个标志数组 将以求得最短路径的标志位 置为1
 *                   首先将最短路径的数组置为 从此顶点到其他顶点的直接权值  ， 每次遍历一遍 取最小值 然后再
 *                   通过最短路径对应的顶点修改数组中的相关最短路径 ， 遍历时 ，每次的最小值一定是最短路径
 *					 
 *                   因为如果这不是最短路径 则一定存在通过其他顶点可以到达的最短路径 但是从此顶点到这个“其他”顶点
 *					 都要比最短路径长 ， 所以 最小值一定是最短路径
** ******************************************************************************************************************
*/

void ShorttestPath_Difkstar (pMGraph G , int v0 , Patharc p , ShortPathTable D  )
{
	// G 表示要查找的 图
	// v0 表示起始的顶点
	// p 表示 存取最短路径下标
	// D 存取到各个顶点的最短路径总的权值

	int a ;
	int v , w , k ,min ;
	int final[MAX_SIZE];  // 标记是否取得最短路径 


	for (v = 0 ; v < G->Vexnum ; v++)
	{
		final[v] = 0 ;	         // 全部顶点初始化为未找到最短路径
		D[v] = G->arcs[v0][v];   // 将与v0 点有连线的顶点加上权值
		p[v] = 0;				 // 存放顶点的前驱
	}
	D[v0] = 0 ;					 // v0 至 v0 的路径为 0 ;
	final[v0] = 1 ;				 // v0 至 v0 不需要路径

	// 开始主循环 ，每次求得 v0 到某个 v 顶点的最短路径 

	for (v = 1 ; v < G->Vexnum ; v++)
	{
		min = 0x7fffffff;
		
		// 第一阶段 未有标记的地方找到最短的一处
		for (w = 0 ; w < G->Vexnum ; w++) 		
		{                      
			if (!final[w] && D[w] < min)
			{
				k = w ;
				min = D[w];
			}
		}

		final[k] = 1 ;	  // 将目前找到的最近的顶点置为1 

		// 修正当前最短路径及距离

		for (w = 0 ; w < G->Vexnum ; w++)
		{
			// 如果经过 v 顶点的路径比现在这条路径的长度短话 , 更新!
			if(!final[w] && (min + G->arcs[k][w] < D[w]))   // 算法核心问题
			{
				D[w] = min + G->arcs[k][w];	                // 修改当前的最短路径
				p[w] = k;					                // 存放前驱顶点
			}
		}
		
	}
}