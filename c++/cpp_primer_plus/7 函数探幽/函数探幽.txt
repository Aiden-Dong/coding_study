1. 内联函数 :
		原理： 编译器使用相应的函数代码替换函数调用 ， 以此来 提高运行速度

		试用:  结构较小的函数

		使用方法 : 函数声明与定义放在主函数前 ，并在头上加关键字 inline 
		
		例如 :  inline int  h_shu (int x , int y) { return x*y ;}

2. 引用变量 :
	
		用途 : 用作函数形参 ；（类似于指针）

		注意 : 
			1. 使用 & 来声明引用 ： int a ; int & b = a;
			2. 必须在声明的同时进行初始化
			3. 引用不可用作数组 （数组只能用指针传递）;
			4. 应尽可能的使用 const

		const 与 普通引用的区别 :
		
				在 普通引用中 : 必须要严格对应  不允许转换

				在 const 引用中: 编译器将在下面两中情况下才进行 转化（生成临时变量）:
						1. 实参类型正确 ， 但不是 左值
						2. 实参类型不正确 ， 但可以转化为正确的类型   
		对象.继承和引用:
				
				详情请看 相关函数

3. 默认参数:

		注意：
			1. 对于带参数列表的函数 ， 需从右到左依次添加默认值;
			2. 实参按照从左到右依次来赋给形参 ， 不允许有跳过现象；
			3. 只在函数原型设置默认值 ；
		
4. 函数重载:

		说明:
			1. 函数重载的关键是函数的参数列表 特征标 不同 ；
				
				特征标问题 : 
						1. 类型引用与类型本身为同一个特征标；
						2. const 与 非const 之间的区别 ， 只适用于指针和引用之间的数据

			2. 使用被重载的函数时 ， 需要在函数调用中使用正确的参数类型 ；

				如果参数类型不正确 （无匹配函数）：
								1. 如果只有唯一的可转换类型 ， 则将进行类型转换；
								2. 如果存在多个可转换方向 ， 则错误

5. 函数模版 :
			
		使用方法 :
		
			例如 ： template <typename AnyType>    // class AnyType
				void Swap (AnyType &a , AnyType &b)
				{
					AnyType temp ;
					temp = a ;
					a = b ;
					b = temp ;
				}
		注意 ：
			函数模版并不能缩短可执行程序， 最终代码不包含任何模版 ， 只有包含了为程序生成的实际函数；



		重载的模版 :
				被重载的模版特征标必须不同



		显式具体化：
				使用方式 :
					template <typename T>
					void Swap (T & , T &);
					template <> void Swap <job> (job& , job&);  // <job> 为可选	


 
				作用 : 
					生成 此模版 的一个实例
				注意：
					试图在同一个文件中使用同种类型的 显示实例 和 显示具体化 将出错



		处理优先级 :非模版函数 > 显式实例化 > 显示具体化 >  普通模版


		重载解析:

			转换最佳到最差的排序：
						1. 完全匹配 
						2. 提升转换（如 char -> short -> int -> long    float -> double）
						3. 标准转换(如  int -> char    long -> double)
						4. 用户定义的转换  

			说明 :
				1. 重载解析是为了寻找最匹配的函数 ， 如果只存在一个这样的函数 ，则选择它 ， 如果存在多个，
				     就寻找更具体的函数 ， 如果程度一样 或 无匹配 则 报错 
 
				 2. 多参数的函数要求：                                                     
							至少有一个参数匹配度要比其他函数高 ， 而余下的参数要不必其他参数


							匹配度差；



6. 模版函数的发展： C++11标准
		
	1. 关键字 decltype

		通用结构： decltype (expression) var;
		
		作用： 为模版提供变量类型
		
		方式：
			1. 如果 expression 是一个没有括号扩起的 标识符 则 var 类型与 该标识符的类型相同
			2. 如果 expression 是一个函数调用 ， 则var 的类型与返回值类型相同
			3. 如果 expression 是一个用括号括起来的左值 则 var 是指向其类型的引用；
			4. 如果 expression 以上都不满足 则 var 应该与 expression 类型相同；

	2 . 另一种 函数声明法 ：
			
			template <class T1 , class T2>
			auto gt (T1 &a, T2&b) -> decltype (a+b)
			{
				decltype (a+b) x = a +b;
				return x;
			}	


































					















 