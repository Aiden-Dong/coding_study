主要内容:
		
	1. 单独编译 ；
	2. 储存持续性. 作用域和链接性；
	3. 定位 new 运算符；
	4. 名称空间；




1. 单独编译：

	头文件中常包含的内容:
		
		函数原型 
		使用 #define 和 const 定义的符号常量
		结构声明
		类声明
		模版声明
		内联函数

	关于 # ifndef  与 # endif：

		编译器首次遇到该文件时 ， 名称如果没有定义 ， 编译器将查看 #ifndef 跟 #endif 中间的内容
		  如果名称以定义 则直接跳转到 # endif 后

2. 存储行 作用域 跟 连续性:

	函数中定义的变量只能在该函数中使用 ， 不可在其他函数中使用 （局部变量）
	而在文件中函数定义之前定义的变量 ， 可在所有函数中使用（本文件）

	链接性为外部的名称可在文件中共享 ， 
	链接性为内部的名称只能由一个（本）文件中的函数共享

	关键字：

		auto (自动类型判断)
		register (自动存储）
		static (静态存储)
		extern (引用)
		thread_local
		mutable：
			指出即使 结构变量 为 const ，其某个成员也可以被修改
		volatile :
			告诉编译器不要优化  （在寄存器中查找值）
		const：
			默认情况下 ， const 全局变量的链接性为内部的（可放在头文件中）；

			如需要将全局变量设为链接性为外部 ， 可使用 extern 关键字来覆盖 ，如 ：
				extern const int a = 50;  这样必须在所有使用该常量的文件中使用 extern声明


	C++ 有四种存储数据的方案（区别是数据保留在内存的时间（持续性））：
	
	
		自动存储持续性(register)：

				作用域为局部 ， 无链接性 ；
				使用栈进行存储 
		
		静态存储持续性:

			如果没有显示初始化 ， 则会自动初始化为0；

			
			外部链接性：
				
				在代码块外部声明 ： 
					要在多个文件中使用外部变量 ， 只需在一个文件中声明该外部变量 在其他的文件中
					使用该外部变量时 ， 用关键字 extern 来声明就可以(必须）
			
				适用于表示常量数据

			内部链接性：

				在代码块外部声明 ， 并使用 static 限定符
			
				只能在其所属的文件内部使用 ， 

				注意：
					1 .如果文件中定义的静态外部变量与另一个文件中声明的常规外部变量相同 ， 则在该文件中
					  将隐藏常规外部变量；

			无链接性：

				在代码块内部声明 ， 并使用 static 限定符 ， 只可以在该代码块中使用 ， 但在该代码块
				不活跃时 内存 依然存在。

		动态存储持续性：

			使用 new 来分配空间 （一般内存位于堆中）

			需手动释放被分配的空间

			int *i = new int -> delete i ;
			int *p = new int [10] -> delete[] p;



		线程存储持续性：



3.定位 new 运算符（需包含头文件 new）：指定要使用的位置；



4. 名称空间：

	名称：
		变量 函数 结构 枚举 类 类和结构的成员


	声明区域：
		可以在其中进行声明的区域；
	潜在作用域：
		从声明点到声明区域结尾；




	使用名称空间的目的：
		提供一个声明名称的区域 ， 使得一个名称空间的区域不会与另一个名称空间的相同名称发生冲突；同时允许程序
			的其他部分使用该名称空间中声明的名称；




	方法 ：
		使用关键字 namespace ; 例如：


						namespace Jack {
								double pail;
								void fetch();
								int pal;
								struct well{....};
								}




	注意：
		1.默认情况下， 在名称空间中声明的名称的链接性为外部的；
		2.任何名称空间的名称不会与其他名称空间的名称相冲突，
		3.名称空间是开放的 ， 即可以把名称加到已有的名称空间中去，例如：
							namespace Jack{
									char *goose (const int * ant);
									}
		4. 全局变量属于全局名称空间；





	访问名称空间的名称：
		
		1. 通过作用域解析运算符 ：：   例如： Jack:: pail = 3.124;
		2. using 声明  ；  例如 ： using Jack::pail;
		3. using 编译指令 ； 例如 ： using namespace Jack;

		小注：
			1. 使用 using 声明 将名称添加到局部声明区域中时 ， 将覆盖同名的全局变量；
			2. 如果使用 using 编译指令， 导入一个已经存在与函数中的名称 ， 则 局部变量会隐藏名称空间名；
				不过可以使用作用域解析运算符：：；
			3. 如果在函数外面使用 ， 将会将名称加到全局变量空间中去；、

			4. 假设名称空间和声明区域定义了相同的名称 ，
					 如果试图使用 using 声明将名称空间的名称导入该声明区域，会出错，             
					 如果使用 using 编译指令倒入 ， 则局部版本会覆盖名称空间版本



		例如：
			namespace Jill{
					double a_hdi (double a , double b);
					int ant;
					double fetch;
					}

			char fetch;
		
			int main ()
			{
				using namespace Jill ;
				double fetch;
				cin >> fetch;           // 局部变量
				cin >> ::fetch;         // 全局变量
				cin >> Jill :: fetch;   // Jill 变量

				return 0;
			}

		


	名称空间的其他特性：
		
		可以将名称空间声明进行嵌套：
				用 ：： 按层查询方式

		可以给名称空间创建别名：
				namespace my_very {};
				namespace mvft = mv_very;

		未命名的名称空间：
				类似链接性为内部的静态变量











