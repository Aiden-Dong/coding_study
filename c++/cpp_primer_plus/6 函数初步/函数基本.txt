函数基础问题 :

	1 定义函数：
			
		函数原型：

    			 作用： 1. 将返回值的类型告知函数 ， 编译器正确处理函数返回值；
				2. 编译器检查使用的参数数目是否正确；
				3. 编译器检查使用的参数类型是否正确 ， 如果不正确 ， 看是否能进行类型转换  

	2. 函数参数和按值传递:

			注意 : 函数调用的实质是按值传递 （复制一个实参的副本）

			局部变量在函数调用完成后将被释放掉内存空间；


	3 .函数与指针问题 :

			指针为解决 较大的内存块在函数调用时的 局限性 节省不必要的空间浪费

			指针解决了 数组的不可按值传递  的缺陷 （数组问题）
 			
			const 与指针传递：

				1 .例如:
					void show_array ( const int a[] , int n );
				             const 起到了保护 数据的作用；
				
				2 . const 作用于至此到变量结束 ， 举例说明一下：
					
					const int * a  ==  int const * a;    // 决定了 （* a） 为常量
					int * const a ;      // 决定了 a 为常量 ， 即所说的地址常量

			说明:

				在一级间接关系中 :
							const 指针可以指向非 const 变量 （不可逆转）;
							
							指针与指针中 : 普通指针可以 赋给 const 指针 (不可逆转)；

				在二级间接关系中 :

 						    	只能同类型转换!!!!!!!!!!!!!
							
							例如 :

  
							int a = 5 ; 
							int  * p = & a;
							const int  ** q = & p; // 不可转换

	4 . 函数与结构 :

			调用的三种方式 :
					1) 传统意义上的按值传递；
					2）使用指针进行传递；
					3）按引用传递；

	5. 函数与 string 对象: (与 结构 类似)

	6 .递归调用

	7.函数指针：

		函数的地址 是 存储其机器语言代码 的内存开始地址;

		例如 :
			void h_shu (int);  -> 指针  void (* p) (int);

                        const double *(*pa[3])(const double ar[] , int n) = {  f1 , f2 , f3 };
			    此处的 f1 等同于 &f1;
		            应用时 *p , p 均可；

	8. 扩展问题：
			
		auto : 自动类型推断

		typedef:  创建类型别名 ， 简化书写方式

			
		        


		

			
			