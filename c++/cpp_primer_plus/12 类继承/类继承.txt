
1.类继承初步：

	派生类的特性：  
			1. 派生类对象包含基类对象 ， 基类的公有成员将成为派生类的公有成员 ； 基类的私有成员也将成为
			   派生类的一部分 ， 但私有成员只能通过基类的公有方法和保护方法访问。
			
			2. 派生类对象存储了基类的数据成员（派生类继承了基类的实现）；

			3. 派生类对象可以使用基类的方法（派生类继承了基类的接口）；

		注意：

			1. 派生类需要自己的构造函数 ； 
			
			2. 派生类可以根据需要添加自己的数据成员和成员函数 ；


	派生类构造函数：

		要点：

			1. 首先创建基类对象 ； 

			2. 派生类构造函数应通过成员函数初始化列表将基类信息传递给基类构造函数 ； 

			3. 派生类构造函数应初始化派生类新增的数据成员 ；

		注意 ：
			
			成员初始化列表只能用于构造函数 ； 


	派生类与基类的关系（自动的转换）:

			1. 基类指针（引用）可以指向派生类对象 ； 
		
			2. 基类对象初始化为派生类对象（隐式的调用复制构造函数） （将派生类的基类部分赋给基类对象）；

			3. 也可以将派生类对象赋给基类对象（默认的赋值运算符）；



继承：  is- a 关系


	多态公有继承 ：

			1. 在派生类中重新定义基类的方法 ； 

			2. 使用虚方法 ；

	注意：

			1.通类与派生类可以定义同一个方法的不同用法（多态） ， 这样 方法的形式取决于对象 ，引用或者是
			  指针调用时多态的方法取决于调用的类型 ； 

			2. 虚函数对多态函数的调用方式取决于对象 ；


静态联编和动态联编：

	指针和引用类型的兼容性：

		将派生类引用或指针转换为基类引用或指针被称为向上强制转换 ；

		在派生类中重新定义基类的方法 ， 则将他设置为虚方法 ，否则 ， 就设置为非虚方法 ；


	重新定义：

		1. 如果重新定义继承方法 ， 应确保与原来的原型完全相同 ， 但如果返回类型是基类的引用或指针 ，可以修改
		   为指向派生类的引用或指针

		2. 如果类声明被重载了 ， 则应在派生类中重新定义所有的版本 ； 如果只定义了一个版本， 则另外两个版本将
		   被隐藏 ；


访问控制：


		privator 和 protected 之间的区别在派生类中才表现出来 ， 派生类的成员可以直接访问基类的保护成员 ， 但不能
		直接访问基类的私有成员；


抽象基类（ABC）：

		1. C++ 通过使用纯虚函数提供为实现的函数 ， 纯虚函数的声明在结尾处为 =0 ;

		2. 当类声明中包含了纯虚函数时， 则不能创建该类的对象（当作ABC）；

		3. ABC 中包含了派生类之间的共同点 ； 



继承和动态内存分配 ：

		当派生类跟基类都采用动态内存分配时 ， 派生类的析构函数、 复制构造函数 、 赋值运算符、 需使用相应的基类
		方法来处理基类元素。

	构造函数：

		派生类的构造函数要使用初始化列表初始化基类成员 ；

	复制构造函数：

		派生类的复制构造函数要调用基类的复制构造函数 （通过初始化列表）， 否则基类将自动调用基类的 默认构造函数 。

	赋值运算符：

		通过作用域解析运算符来显示的调用基类的赋值运算符来完成

包含对象的类：

	valarray 简介 :

		valarray 是一个模版类 ；

		用途 ：
			主要用来构造数组 ：

				double gpa[5] = {3.1 , 3.5 , 3.8 , 2.9 , 3.3} ; 

				valarray <double> vl ; 创建长度为零的空数组 ； 

				valarray <int> v2 (8) ; 创建长度为 8 的空数组 ； 

				valarray <int> v3 (10 , 8) ; 创建长度为 8 所用的值都为 10 的数组 ； 

				valarray <double> v4 (gpa , 4) ; 创建长度为 4 用数组初始化的数组 ；


		方法 ：

			operator [] : 访问数组元素 ；

			size () ;返回元素数 ； 

			max () : 返回最大值 ； 

			sum () : 求所有元素之和 ；

			min () : 求最小值 ；


	注意：

		1.在包含对象的类里 ， 只有对象本身可以访问此对象 ；
		2. 被包含对象可以不使用初始化列表进行初始化 ；


私有继承：

	使用私有继承 ， 基类的共有部分与私有部分以及保护成员都将成为 派生类的私有成员  。 这将意味着基类的方法不能成为
	共有接口的一部分 ， 但可以在派生类中使用他们 ；（注意在多重派生之后--私有继承部分无法直接访问）

	1. 初始化基类组建 ：

		使用初始化列表来进行初始化！！ --必须

	2. 访问基类方法：

		使用私有继承时 ， 只能通过派生类方法来调用基类方法来访问基类方法
		
		注意：  要使用作用域解析运算符 ；

	3 .访问基类对象 ：

		使用强制类型转化 ， 将派生类转化为基类 ；

	4. 访问基类的友元函数：

		通过显示的转化为基类 ， 来调用基类的友元函数 ； 

		例如 ：

		ostream & operator << (ostream & os , const Student &stu )  
									// 假设 Student 是从 string 类 私有继承而来
		｛
			os << (const string & ) stu << endl ;

			return os ;
		｝ 

保护继承：

	使用保护继承时 ， 基类的共有成员和保护成员都将成为派生类的保护成员 ；

	当从派生类派生出另一个类时 ， 私有继承和保护继承之间的主要区别便呈现出来 ，使用私有继承时 ， 第三代类将不能使用
	基类的接口 。 而使用保护继承时 ， 则可以使用基类的接口 ；


多重继承：

	先主要解决两个问题：

		1. 从不同基类继承同名方法 ； 
		2. 从多个类继承了多个相同祖先 ；


	解决多个同基类问题：

		通过在类声明中使用关键字 virtual ; 将基类用作派生类的虚基类 ；方法如下：
			
			class Singer : virtual public Worker {}

		从相同虚基类派生出的派生类共享一个副本 ；

		注意 ：

			C++ 在基类为虚基类时 ， 禁止信息通过 中间类 传递给基类 ， 如果不希望用默认构造函数构造基类 ，
			必须显式的调用基类的构造函数 ；


	解决多方法问题：

		如果某个名称优先于其他所有名称 ， 则不会产生二义性 ， 否则要使用作用域解析运算符 ；指出是使用的那个类

























 