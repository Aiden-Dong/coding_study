类模版：

	 模版提供参数化类型 ， 即能够将类型名用作参数传递给接收方来建立类或者是函数 ； 


	1. 定义类模版：
	
		模版类以如下代码开头：
					template <class Type>      // or    template <typename Type>
		
		注意：

			1. 不能将模版成员函数放在独立的实现文件中 ， 由于模版不是函数 ， 他们不能单独进行编译 ， 模版
			   必须与模版实例化请求一起使用 ， 为此最简单的方法就是将所有的模版信息放在同一个头文件中
			
			2. 在定义模版成员函数时 ， 都将必须使用 template <class Type> 开头 ；

	2. 使用模版类 ：

		注意 ：

			必须要显式的提供所需要的类型 ；

	
	3. 深入的讨论模版类：

		在 如 ：template <class T , int n>  等的类模版中指定特殊的类型而不是使用参数的（如：n） 为非类型参数
		或表达式参数 ；

		注意：

			1. 表达式参数可以是整数 ， 枚举 ，引用或是指针 ； 
			2. 模版代码不能改变表达式参数的值 ； 也不能使用参数的地址 ；
			3. 实例化模版时 ，用作表达参数的值必须是常量表达式 ；
			4. 表达是参数的主要缺点是 ： 每个类对象声明都将生成独立的类声明 ；
			5. 可以为类型参数提供默认值 ； 也可为表达式参数提供默认值 ；

	4. 模版的多功能性 ：

		模版类可用作基类、组件类、其他模版参数等 ；


		递归使用模版类 ：

			ArrayTp <ArrayTP <int , 5> , 10> twode ;   // 声明包含5 个int数组的10个数组（二维数组概念）


	5.模版具体化 ：

		隐式实例化 ：

				当声明类对象时 ， 指出所需的类型 ， 编译器使用通用的模版提供的处方生成具体的类定义 ；
				编译器在需要对象之前 ， 不会生成类的隐式实例化 ；

		显式实例化 ：

				当使用关键字 template 并指出所需的类型时 ， 编译器将生成类声明的显示实例化 ， 声明必须
				位于模版定义的名称空间中 ； 

				如 ： template class ArrayTP <string , 100> ; 

		显式具体化：

				显式具体化是特定类型（用于替换模版中的泛型）的定义 ； 主要用于对于特殊的与泛型行为不同
				的类型 ； 创建显式具体化使之代替模版

				定义格式如 ：

						template <> class Classname <type-name>
						{.....};


		部分具体化：

				部分限制模版的通用性 :

				template <class T1 , class T2> class Pai{....};
				template <class T1> class Pai <class T1 , int> {.......};


				template 后面的 <> 里是没有被具体化的类型参数 ； 因此上述第二个声明将 T2 具体化为int


				如果对象有多个模版可供选择 ， 编译器将使用匹配程度最高的模版 ； 、

	6. 成员模版 :

		类模版可用于结构、类或模版类的成员

		也可将模版用作--参数：

			如：
				template <template <typename T>class Thing>
				class Carb 
				{.......};

			假设有如下声明 ：
				Carb <king>legs ; // king 必须是一个模版类 ；

	7. 模版类和友元 ：

		非模版友元函数 ：

		约束模版友元函数：

				1. 在类定义的前面声明每个模版函数 ； 
				2. 在函数中再次将模版声明为友元 。 这些语句根据类模版参数的类型声明具体化 ；
				3. 为友元模版提供定义 ； 

		非约束模版友元函数：

				通过在类内声明模版 ， 可以创建非约束模版友元函数 ， 即每个函数具体化都是每个类具体化的
				友元。 
				
				对于非约束友元，友元模版类型参数与模版类型参数是不同的 ； 






	
		




































		  