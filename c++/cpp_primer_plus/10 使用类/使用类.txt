1.运载符重载：

	格式： 
		operator op (arguement-list); 		// op  代表了运算符 

	注意：
		1.只能通过成员函数进行重载的运算：
						=   （）   []     ->
  


2. 友元函数：

		特殊的可以访问类的私有成员的 非成员函数；



	创建友元函数：
		  	
		第一步：
			
			将其原型放在类声明中， 并在原型声明前加关键字 friend；
			   
				例如：
					friend Time operate * ( double x ,const Time & t)

			说明：
				1. 他不是成员函数 ， 不能使用成员运算符来调用；
				2. 虽然他不是成员函数 ， 但具有成员函数的访问权；

		第二部：

			编写函数定义 ， 因为他不是成员函数 ， 所以不要使用 类的作用域解析运算符（：：）		
			还有就是不要在定义中使用关键字 frend;





3. 类的自动类型转换和强制类型转换：

	
	类型转换 （一般用于将 普通变量 转换为 类对象式）：

			接受 一个参数 的 构造函数 可以成为 转换函数 
							（如果构造函数有多个值 可以将其他参数设置为默认参数）

		

			隐式类型转换：

				例如：   Stock (int a);      Stock myCat ;   myCat = 20;
			
				对于隐式转换 ， 偶尔会导致意外的类型转换 ， 可以使用 explicit 关闭隐式转换

				方法：
					explicit Stock ( int a ); 
 

			显式类型转换：

					例如：
						Sotck myCat ;    myCat = Stock (20); // (Stock)20;




			注意：   使用了关键字 explicit 后， 只能使用显示类型转换；否则还可以使用下面的隐式转换：
					
					1. 将 类对象 初始化为 一个值时；
					2. 将 一个值 传递给 一个类对象时；
					3. 将一个 普通变量 传递给接受 类对象 参数的函数时；
					4. 返回值被声明为 类对象 却返回 一个普通变量时；



		
	转换函数 （一般用于将 类对象 转化为 普通变量）：

		格式：

			operator typename();    // typename 为要转换的类型

		
		注意：
			1. 转换函数必须是类方法；
			2. 转换函数不能指定返回类型；
			3. 转换函数不能有参数；
			4. 当类有多种转换时 ， 应使用显式的类型转换指出要转换的版本 ， 否则产生二义性
			5. C++ 98 中关键字 explicit 不能用于转换函数 ， 而 C++11 中消除了这种限制， 允许声明为显式； 














