1.  静态类说明：

		静态类数据成员说明：

			对于静态类数据成员 ， 可以在声明之外使用单独语句来进行初始化 ， 这是因为静态类成员是单独存储的，
			并非是对象的组成部分 ；
				
			注意：
				1. 初始化语句要指出类型 ， 并使用作用域解析运算符，不要再加 static ；
				2. 静态变量只存在一个副本 ， 所有的对象都将共享一个变量副本；

		静态类成员函数：

			首先 ， 不能通过对象调用静态成员函数， 实际上 ， 静态成员函数甚至不能使用 this 指针 。 如果
			静态成员函数是在 public 中声明 ， 可以用 类名 加 作用域解析运算符 调用它 ，
			其次 ， 由于静态成员函数不能与特定的对象关联 ， 因此只能使用静态数据成员 ， 不能调用其他；


2. 特殊的成员函数：

		构造函数：
			默认构造函数：
			普通构造函数：
					多参构造函数：
					一参构造函数：（可用作转换函数）：
			复制构造函数：
			重载运算符：
					赋值运算符：
					地址运算符：
					其他运算符：
					类型运算符：（逆转换函数）

			复制构造函数：
		
				用于将一个对象复制给另一个对象时 ， 复制函数将被调用 ， 也就是说它用于初始化中里面包括
				按值传递参数 生成临时对象 返回对象 时  ；

				原型：

					Class_name (const Class_name &)

				默认的复制构造参数：

					逐个的复制 非静态成员 

			
			赋值运算符：

				将已有的对象赋给另一个对象时 ， 将使用赋值运算符（初始化时，并不一定会使用赋值运算符
				一般使用复制构造函数）
				与复制构造函数类似，赋值运算符的隐式表达也对成员进行逐个复制，如果成员本身就是类对象，
				则程序将为这个类定义的赋值运算符来复制该成员； 
				静态变量则不受影响；


使用类的 new 时的注意事项：


	应定义一个复制构造函数 ， 通过深度的复制将一个对象传递给另一个对象；
	应定义一个赋值运算符 ，通过深度的复制将一个对象传递给另一个对象；

	new -> delete      new[] -> delete[];

	构造函数类型要相对应

	使用指向对象的指针：

			注意使用 new 时 要使用 delete 来释放

			关于定位 new 运算符：

					对于这种情况要释放对象必须显式的调用 析构函数 

					如：	pc->~strock(); 


有关 返回对象的说明：

		如果方法或者函数要返回的是局部变量则应该返回对象（按值传递）；
		如果函数或方法返回一个没有公共复制构造函数的类的对象 ， 他必须要返回引用 （避免释放内存时出错）
		一般情况下首先考虑要返回对象的引用；











			
















































